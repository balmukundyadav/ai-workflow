Skip to content
Chat history

You said:
I would like to create fastapi service that will have four endpoints 
first build index to create azure search index
second to insert data to created index
ChatGPT said:
To create a FastAPI service with four endpoints for working with Azure Cognitive Search, we can start by implementing the first two:

POST /build-index ‚Äì Creates an Azure Search index.

POST /insert-data ‚Äì Inserts documents into the created index.

We'll define a FastAPI app that uses Azure SDKs, and you‚Äôll need your Azure Search service name, admin key, and optionally the index name and data schema.

‚úÖ Prerequisites
Install the required libraries:

pip install fastapi uvicorn azure-search-documents python-dotenv
Add your Azure Search credentials to a .env file:

AZURE_SEARCH_ENDPOINT=https://<your-search-service>.search.windows.net
AZURE_SEARCH_API_KEY=<your-admin-key>
AZURE_SEARCH_INDEX_NAME=my-index
üß† Basic Directory Structure
fastapi_azure_search/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ search_utils.py
‚îú‚îÄ‚îÄ models.py
‚îî‚îÄ‚îÄ .env
üì¶ models.py ‚Äì Pydantic schemas
from pydantic import BaseModel
from typing import List, Dict, Any

class IndexSchema(BaseModel):
    name: str
    fields: List[Dict[str, Any]]  # Field definitions in Azure schema format

class InsertDataRequest(BaseModel):
    documents: List[Dict[str, Any]]
üîß search_utils.py ‚Äì Azure Search helpers
import os
from azure.core.credentials import AzureKeyCredential
from azure.search.documents.indexes import SearchIndexClient
from azure.search.documents import SearchClient
from azure.search.documents.indexes.models import SearchIndex
from dotenv import load_dotenv

load_dotenv()

endpoint = os.getenv("AZURE_SEARCH_ENDPOINT")
api_key = os.getenv("AZURE_SEARCH_API_KEY")

credential = AzureKeyCredential(api_key)

def create_index(index_name: str, fields: list):
    index_client = SearchIndexClient(endpoint=endpoint, credential=credential)
    index = SearchIndex(name=index_name, fields=fields)
    result = index_client.create_index(index)
    return result

def insert_documents(index_name: str, documents: list):
    search_client = SearchClient(endpoint=endpoint, index_name=index_name, credential=credential)
    result = search_client.upload_documents(documents)
    return result
üöÄ main.py ‚Äì FastAPI application
from fastapi import FastAPI, HTTPException
from models import IndexSchema, InsertDataRequest
from search_utils import create_index, insert_documents

app = FastAPI()

@app.post("/build-index")
def build_index(payload: IndexSchema):
    try:
        result = create_index(payload.name, payload.fields)
        return {"message": "Index created", "index": result.name}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/insert-data")
def insert_data(payload: InsertDataRequest):
    try:
        index_name = os.getenv("AZURE_SEARCH_INDEX_NAME")
        result = insert_documents(index_name, payload.documents)
        return {"message": "Documents inserted", "status": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
‚úÖ Running the FastAPI server
uvicorn main:app --reload
üìå Example Requests
Create Index:

POST /build-index

{
  "name": "my-index",
  "fields": [
    { "name": "id", "type": "Edm.String", "key": true, "filterable": true },
    { "name": "title", "type": "Edm.String", "searchable": true },
    { "name": "content", "type": "Edm.String", "searchable": true }
  ]
}
Insert Documents:

POST /insert-data

{
  "documents": [
    { "id": "1", "title": "Test 1", "content": "This is a test document." },
    { "id": "2", "title": "Test 2", "content": "Another document here." }
  ]
}
Would you like to continue with the next two endpoints (e.g., search and delete)?

You said:
also i would like to add third endpoint to search the index by passing the query or search context and fourth endpoint to delete the specified search index from azure search
ChatGPT said:
Perfect! Let's extend your FastAPI service to include:

POST /search ‚Äì Search the Azure index using a query string or search context.

DELETE /delete-index/{index_name} ‚Äì Delete a specified Azure Search index.

üõ†Ô∏è Full Updated Implementation
‚úÖ Updated models.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class IndexSchema(BaseModel):
    name: str
    fields: List[Dict[str, Any]]

class InsertDataRequest(BaseModel):
    documents: List[Dict[str, Any]]

class SearchRequest(BaseModel):
    query: str
    index_name: Optional[str] = None
    top: Optional[int] = 5  # Number of results to return
‚úÖ Updated search_utils.py
import os
from azure.core.credentials import AzureKeyCredential
from azure.search.documents.indexes import SearchIndexClient
from azure.search.documents import SearchClient
from azure.search.documents.indexes.models import SearchIndex
from dotenv import load_dotenv

load_dotenv()

endpoint = os.getenv("AZURE_SEARCH_ENDPOINT")
api_key = os.getenv("AZURE_SEARCH_API_KEY")

credential = AzureKeyCredential(api_key)

def create_index(index_name: str, fields: list):
    index_client = SearchIndexClient(endpoint=endpoint, credential=credential)
    index = SearchIndex(name=index_name, fields=fields)
    return index_client.create_index(index)

def insert_documents(index_name: str, documents: list):
    search_client = SearchClient(endpoint=endpoint, index_name=index_name, credential=credential)
    return search_client.upload_documents(documents)

def search_documents(index_name: str, query: str, top: int = 5):
    search_client = SearchClient(endpoint=endpoint, index_name=index_name, credential=credential)
    results = search_client.search(query, top=top)
    return [doc for doc in results]

def delete_index(index_name: str):
    index_client = SearchIndexClient(endpoint=endpoint, credential=credential)
    index_client.delete_index(index_name)
    return {"message": f"Index '{index_name}' deleted."}
‚úÖ Updated main.py
from fastapi import FastAPI, HTTPException
from models import IndexSchema, InsertDataRequest, SearchRequest
from search_utils import create_index, insert_documents, search_documents, delete_index
import os

app = FastAPI()

@app.post("/build-index")
def build_index(payload: IndexSchema):
    try:
        result = create_index(payload.name, payload.fields)
        return {"message": "Index created", "index": result.name}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/insert-data")
def insert_data(payload: InsertDataRequest):
    try:
        index_name = os.getenv("AZURE_SEARCH_INDEX_NAME")
        result = insert_documents(index_name, payload.documents)
        return {"message": "Documents inserted", "status": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/search")
def search_index(payload: SearchRequest):
    try:
        index_name = payload.index_name or os.getenv("AZURE_SEARCH_INDEX_NAME")
        results = search_documents(index_name=index_name, query=payload.query, top=payload.top)
        return {"results": results}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/delete-index/{index_name}")
def delete_search_index(index_name: str):
    try:
        result = delete_index(index_name)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
üß™ Example Usage
üîç POST /search
{
  "query": "test document",
  "top": 3
}
üóëÔ∏è DELETE /delete-index/my-index
DELETE /delete-index/my-index
Would you like me to help you package this into a GitHub-ready project or a Docker container for deployment?

You said:
please create full flagged service that can be scalable 
ChatGPT said:
Updated saved memory
Here's a scalable, production-ready FastAPI service for managing Azure Cognitive Search. It includes:

‚úÖ Four endpoints:

POST /build-index ‚Äì Create a search index

POST /insert-data ‚Äì Insert documents

POST /search ‚Äì Search the index

DELETE /delete-index/{index_name} ‚Äì Delete index

‚úÖ Production-Ready Features:

Modular code structure

Centralized logging

.env config management

Azure SDK integration

Typed schemas with Pydantic

Uvicorn-compatible for ASGI hosting

Scalable with containers or Azure App Service

üìÅ Project Structure
azure_search_service/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ routes.py
‚îÇ   ‚îú‚îÄ‚îÄ azure_search.py
‚îÇ   ‚îî‚îÄ‚îÄ logger.py
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ run.sh
üîß Configuration ‚Äì .env
AZURE_SEARCH_ENDPOINT=https://<your-service>.search.windows.net
AZURE_SEARCH_API_KEY=<your-admin-key>
DEFAULT_INDEX_NAME=my-index
üì¶ requirements.txt
fastapi
uvicorn
azure-search-documents
python-dotenv
üß† app/config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    AZURE_SEARCH_ENDPOINT = os.getenv("AZURE_SEARCH_ENDPOINT")
    AZURE_SEARCH_API_KEY = os.getenv("AZURE_SEARCH_API_KEY")
    DEFAULT_INDEX_NAME = os.getenv("DEFAULT_INDEX_NAME", "default-index")

settings = Settings()
üßæ app/models.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class IndexSchema(BaseModel):
    name: str
    fields: List[Dict[str, Any]]

class InsertDataRequest(BaseModel):
    documents: List[Dict[str, Any]]
    index_name: Optional[str] = None

class SearchRequest(BaseModel):
    query: str
    index_name: Optional[str] = None
    top: Optional[int] = 5
üîß app/logger.py
import logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
logger = logging.getLogger(__name__)
üîç app/azure_search.py
from azure.core.credentials import AzureKeyCredential
from azure.search.documents.indexes import SearchIndexClient
from azure.search.documents.indexes.models import SearchIndex
from azure.search.documents import SearchClient
from app.config import settings
from app.logger import logger

credential = AzureKeyCredential(settings.AZURE_SEARCH_API_KEY)

def get_index_client():
    return SearchIndexClient(endpoint=settings.AZURE_SEARCH_ENDPOINT, credential=credential)

def get_search_client(index_name):
    return SearchClient(endpoint=settings.AZURE_SEARCH_ENDPOINT, index_name=index_name, credential=credential)

def create_index(index_name: str, fields: list):
    client = get_index_client()
    index = SearchIndex(name=index_name, fields=fields)
    logger.info(f"Creating index: {index_name}")
    return client.create_index(index)

def insert_documents(index_name: str, documents: list):
    client = get_search_client(index_name)
    logger.info(f"Inserting documents to index: {index_name}")
    return client.upload_documents(documents)

def search_documents(index_name: str, query: str, top: int = 5):
    client = get_search_client(index_name)
    logger.info(f"Searching index: {index_name} with query: {query}")
    results = client.search(query, top=top)
    return [doc for doc in results]

def delete_index(index_name: str):
    client = get_index_client()
    logger.info(f"Deleting index: {index_name}")
    client.delete_index(index_name)
    return {"message": f"Index '{index_name}' deleted"}
üåê app/routes.py
from fastapi import APIRouter, HTTPException
from app.models import IndexSchema, InsertDataRequest, SearchRequest
from app.azure_search import create_index, insert_documents, search_documents, delete_index
from app.config import settings

router = APIRouter()

@router.post("/build-index")
def build_index(payload: IndexSchema):
    try:
        result = create_index(payload.name, payload.fields)
        return {"message": "Index created", "index": result.name}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/insert-data")
def insert_data(payload: InsertDataRequest):
    try:
        index_name = payload.index_name or settings.DEFAULT_INDEX_NAME
        result = insert_documents(index_name, payload.documents)
        return {"message": "Documents inserted", "status": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/search")
def search_index(payload: SearchRequest):
    try:
        index_name = payload.index_name or settings.DEFAULT_INDEX_NAME
        results = search_documents(index_name, payload.query, payload.top)
        return {"results": results}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/delete-index/{index_name}")
def delete_search_index(index_name: str):
    try:
        return delete_index(index_name)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
üöÄ app/main.py
from fastapi import FastAPI
from app.routes import router

app = FastAPI(title="Azure Search FastAPI Service", version="1.0")

app.include_router(router)
üîÑ run.sh (for local dev)
#!/bin/bash
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
Make it executable:

chmod +x run.sh
üê≥ Optional: Docker Setup
Let me know if you'd like a full Dockerfile, docker-compose.yml, or CI/CD support for this project.

Would you like me to upload this full project as a GitHub-ready repo or zip?




No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.


























Absolutely, let's create a complete application using GPT Actions to fetch information from Confluence wiki for user queries. This example will involve setting up FastAPI, integrating with Confluence, using GPT for routing queries, and fetching relevant data.

### Step-by-Step Guide:

1. *Set up FastAPI*: For building the API endpoints.
2. *Integrate Confluence*: Load and search Confluence pages.
3. *Use GPT for Routing*: Decide which Confluence index to query based on user input.
4. *Fetch and Return Data*: Retrieve data from Confluence and present it to the user.

### Complete Code Example

*Filename*: confluence_search_app.py

python
from fastapi import FastAPI, HTTPException
import requests
import openai

app = FastAPI()

# Configuration for Confluence and OpenAI
CONFLUENCE_BASE_URL = "https://your_confluence_instance.atlassian.net/wiki"
CONFLUENCE_API_TOKEN = "your_confluence_api_token"
CONFLUENCE_USER_EMAIL = "your_confluence_user_email"

OPENAI_API_KEY = "your_openai_api_key"
openai.api_key = OPENAI_API_KEY

# Confluence space indexes (example)
CONFLUENCE_INDEXES = {
    "index1": "space1",
    "index2": "space2",
    "index3": "space3",
}

# Function to query Confluence
def query_confluence(space_key, query):
    url = f"{CONFLUENCE_BASE_URL}/rest/api/space/{space_key}/content/search"
    params = {"cql": f"text ~ '{query}'"}
    auth = (CONFLUENCE_USER_EMAIL, CONFLUENCE_API_TOKEN)
    response = requests.get(url, params=params, auth=auth)
    response.raise_for_status()
    return response.json()

# Function to use GPT to decide the index
def decide_index(query):
    prompt = f"Based on the following user query, which Confluence space (index1, index2, index3) should be queried: {query}?"
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompt,
        max_tokens=10
    )
    index = response.choices[0].text.strip()
    if index not in CONFLUENCE_INDEXES:
        raise ValueError("Invalid index returned by GPT")
    return index

@app.post("/search")
def search_confluence(query: str):
    try:
        index = decide_index(query)
        space_key = CONFLUENCE_INDEXES[index]
        results = query_confluence(space_key, query)
        return {"index": index, "results": results}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="An error occurred while processing your request")

# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


### Breakdown:
1. *FastAPI Setup*: Initializes the API with endpoints.
2. *Confluence Integration*: Uses Confluence API to search specific spaces.
3. *GPT Decision Making*: GPT-3 (or similar) decides which Confluence space to query based on the user‚Äôs input.
4. *Query Execution*: Retrieves the relevant data from Confluence and returns it.

This way, user queries are smartly routed and processed, leveraging both GPT‚Äôs capabilities and Confluence‚Äôs powerful search functionality. Ready to¬†implement¬†this?
